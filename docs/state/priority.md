Through [updated mental model](./mental.html), we learned that `update` has `priority`.

So what is `priority`? What is the basis of `priority`? How to decide which status should be updated first by `priority`?

We will explain in detail in this section.

## What is priority

In the [React concept section](../preparation/idea.html#Understanding-Respond naturally) we talked about how `React` integrates the results of human-computer interaction research into the real `UI`. Specifically, what does this mean when `React` is running?

The `status update` is generated by the `user interaction`, and the user has an expectation for the execution order of the `interaction` in mind. According to the results of the research on human-computer interaction, `React` assigns different priorities to the `status update` generated by the `interaction` according to the user's expected order of `interaction`.

details as follows:

-Life cycle method: synchronous execution.

-Controlled user input: For example, input text in the input box and execute synchronously.

-Interactive events: such as animation, high priority execution.

-Others: such as data request, low priority execution.

## How to schedule priority

We mentioned in [New React Structure Section](../preparation/newConstructure.html) that `React` schedules tasks through `Scheduler`.

Specific to the code, whenever a task needs to be scheduled, `React` will call the method `runWithPriority` provided by `Scheduler`.

This method receives a `priority` constant and a `callback function` as parameters. The `callback function` will be arranged in a `timer` in the order of `priority` high and low and will be triggered at an appropriate time.

For updates, the `callback function` passed is generally the entry function of the `render phase` mentioned in the [State Update Process Overview](./prepare.html#start of the render phase).

> You can see the definition of the `runWithPriority` method in [==unstable_runWithPriority== here](https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/scheduler/src/Scheduler.js#L217). In [here](https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/scheduler/src/SchedulerPriorities.js) see the definition of `Scheduler` for priority constants.

## example

The priority will eventually be reflected in the `update.lane` variable. Currently we only need to know that this variable can distinguish the priority of `Update`.

Next, we use an example to explain how the priority determines the order of updates in combination with the relevant fields of `Update` introduced in the previous section.

> This example comes from [React Core Team Andrew's tweet explaining the Update workflow to netizens](https://twitter.com/acdlite/status/978412930973687808)

<img :src="$withBase('/img/update-process.png')" alt="How does priority determine the order of updates">

In this example, there are two `Update`. We call the `Update` generated by "turn off the night mode" as `u1`, and the `Update` generated by entering the letter "I" as `u2`.

Among them, `u1` is triggered first and enters the `render phase`. Its priority is lower and its execution time is longer. at this time:

```js
fiber.updateQueue = {
  baseState: {
    blackTheme: true,
    text:'H'
  },
  firstBaseUpdate: null,
  lastBaseUpdate: null
  shared: {
    pending: u1
  },
  effects: null
};
```

Before `u1` completes the `render stage`, the user enters the letter "I" through the keyboard, resulting in `u2`. `u2` belongs to **controlled user input** and has a higher priority than `u1`, so the `render phase` generated by `u1` is interrupted.

at this time:

```js
fiber.updateQueue.shared.pending === u2 ----> u1
                                     ^ |
                                     |________|
// which is
u2.next === u1;
u1.next === u2;
```

Among them, the priority of `u2` is higher than that of `u1`.

Next enter the `render phase` generated by `u2`.

In the `processUpdateQueue` method, the `shared.pending` circular linked list will be cut and spliced ​​behind the `baseUpdate`.

To be clear, `shared.pending` points to the last `pending` of `update`, so the order of `update` in actual execution is:

```js
u1 - u2
```

Next, traverse `baseUpdate` and process `Update` with the appropriate priority (this time it is processed with higher priority `u2`).

Since `u2` is not the first `update` in `baseUpdate`, the previous `u1` is skipped due to insufficient priority.

There may be a dependency between `update`, so the skipped `update` and all subsequent `update` will become the `baseUpdate` of the next update. (Ie `u1 - u2`).

Finally, `u2` completes the `render-commit phase`.

at this time:

```js
fiber.updateQueue = {
  baseState: {
    blackTheme: true,
    text:'HI'
  },
  firstBaseUpdate: u1,
  lastBaseUpdate: u2
  shared: {
    pending: null
  },
  effects: null
};
```

Another update will be scheduled at the end of the `commit` phase. In this update, a new `render phase` will be started based on the `u1` saved by `firstBaseUpdate` in `baseState`.

The result of the final two `Update` is as follows:

```js
fiber.updateQueue = {
  baseState: {
    blackTheme: false,
    text:'HI'
  },
  firstBaseUpdate: null,
  lastBaseUpdate: null
  shared: {
    pending: null
  },
  effects: null
};
```

We can see that the update corresponding to `u2` is executed twice, and the life cycle hook `componentWillXXX` of the corresponding `render phase` will also be triggered twice. This is why these hooks are marked as `unsafe_`.

## How to ensure the status is correct

Now we have basically mastered the workflow of `updateQueue`. There are two more questions:

-The `render phase` may be interrupted. How to ensure that the `Update` saved in the `updateQueue` is not lost?

-Sometimes the current `state` needs to depend on the previous `state`. How to ensure the continuity of **state dependence** while supporting the skipping of `low priority states`?

Let's explain them separately.

### How to ensure that `Update` is not lost

In the [previous section example](./update.html#example) we mentioned that in the `render phase`, the loop of `shared.pending` is cut and connected to the back of `updateQueue.lastBaseUpdate`.

In fact, `shared.pending` will be connected after `workInProgress updateQueue.lastBaseUpdate` and `current updateQueue.lastBaseUpdate` at the same time.

> For the specific code, see [here](https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactUpdateQueue.new.js#L424)

When the `render phase` is interrupted and restarted, the `workInProgress updateQueue` will be cloned based on the `current updateQueue`. Since `current updateQueue.lastBaseUpdate` has saved the last `Update`, it will not be lost.

When the `commit phase` finishes rendering, since the last `Update` is saved in `workInProgress updateQueue.lastBaseUpdate`, the `Update` will not be lost after the `workInProgress Fiber tree` becomes the `current Fiber tree`.

### How to ensure the continuity of state dependence

When a certain `Update` is skipped due to low priority, not only the `Update` is saved in the `baseUpdate`, but also all `Update` after the `Update` in the linked list.

Consider the following example:

```js
baseState:''
shared.pending: A1 --> B2 --> C1 --> D2
```

Among them, the `letter` represents the letter to be inserted into the page of the `Update`, and the `number` represents the `priority`, the lower the value, the higher the `priority`.

For the first `render`, the `priority` is 1.

```js
baseState:''
baseUpdate: null
Update used in the render stage: [A1, C1]
memoizedState:'AC'
```

Among them, `B2` has a priority of 2, which is lower than the current priority, so it and all subsequent `Update` will be saved in `baseUpdate` as the next update of `Update` (ie `B2 C1 D2`) .

This is done to maintain the dependency order of the `state`.

In the second `render`, the `priority` is 2.

```js
baseState:'A'
baseUpdate: B2 --> C1 --> D2
Update used in the render stage: [B2, C1, D2]
memoizedState:'ABCD'
```

Note that `baseState` is not the last updated `memoizedState`. This is because `B2` was skipped.

That is, when `Update` is skipped, `baseState of next update !== memoizedState of last update`.

> See [here](https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactUpdateQueue.new.js#L479) for the logic of skipping `B2`

Through the above example, we can find that `React` guarantees that the final state must be consistent with the `interaction` triggered by the user, but the state of the intermediate process may be different due to different devices.

:::details High-priority tasks interrupt low-priority tasks Demo

[Follow the public account](../me.html), backstage reply **815** to get the online Demo address

:::

## Reference

[In-depth source code analysis why componentWillXXX is UNSAFE](https://juejin.im/post/5f05a3e25188252e5c576cdb)

[Annotation to explain the Update workflow and priority in the React source code](https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactUpdateQueue.new.js#L10)

[React Core Team Andrew's tweet explaining the Update workflow to netizens](https://twitter.com/acdlite/status/978412930973687808)

<!-- beginWork getStateFromUpdate -->