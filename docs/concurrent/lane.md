In the previous section, we mentioned that `Scheduler` and `React` are two sets of `priority` mechanisms. In `React`, there are many situations where different `priorities` are used, such as:

Note: The following examples are all cases where `Concurrent Mode` is turned on

-Overdue tasks or synchronized tasks use `Synchronization` priority

-Updates generated by user interaction (such as click events) use high priority

-Updates generated by network requests use general priority

-`Suspense` uses low priority

`React` needs to design a set of `priority` mechanism that meets the following needs:

-Can indicate the difference of `priority`

-There may be several `updates` with the same `priority` at the same time, so it must be able to express the concept of `batch`

-Facilitate calculation of `priority`

In order to meet the above requirements, `React` designed the `lane` model. Next, let's see how the `lane` model satisfies the above three conditions.

## Indicates the difference in priority

Imagine you are in a racing circuit.

<img :src="$withBase('/img/lane.jpeg')" alt="30sec">

Different cars gallop on different tracks. The total track length of the inner ring is shorter and the outer ring is longer. The length of certain nearby tracks can be regarded as almost long.

The `lane` model draws on the same concept and uses a 31-bit binary to represent 31 tracks. The smaller the number of tracks, the higher the priority. Some adjacent tracks have the same priority.

as follows:

```js
export const NoLanes: Lanes = /* */ 0b0000000000000000000000000000000;
export const NoLane: Lane = /* */ 0b0000000000000000000000000000000;

export const SyncLane: Lane = /* */ 0b0000000000000000000000000000001;
export const SyncBatchedLane: Lane = /* */ 0b0000000000000000000000000000010;

export const InputDiscreteHydrationLane: Lane = /* */ 0b0000000000000000000000000000100;
const InputDiscreteLanes: Lanes = /* */ 0b0000000000000000000000000011000;

const InputContinuousHydrationLane: Lane = /* */ 0b0000000000000000000000000100000;
const InputContinuousLanes: Lanes = /* */ 0b0000000000000000000000011000000;

export const DefaultHydrationLane: Lane = /* */ 0b0000000000000000000000100000000;
export const DefaultLanes: Lanes = /* */ 0b0000000000000000000111000000000;

const TransitionHydrationLane: Lane = /* */ 0b0000000000000000001000000000000;
const TransitionLanes: Lanes = /* */ 0b0000000001111111110000000000000;

const RetryLanes: Lanes = /* */ 0b0000011110000000000000000000000;

export const SomeRetryLane: Lanes = /* */ 0b0000010000000000000000000000000;

export const SelectiveHydrationLane: Lane = /* */ 0b0000100000000000000000000000000;

const NonIdleLanes = /* */ 0b0000111111111111111111111111111;

export const IdleHydrationLane: Lane = /* */ 0b0001000000000000000000000000000;
const IdleLanes: Lanes = /* */ 0b0110000000000000000000000000000;

export const OffscreenLane: Lane = /* */ 0b1000000000000000000000000000000;
```

> You can see the definition of `lane` in [here](https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberLane.js#L77-L107)

Among them, the track occupied by synchronization priority is the first:

```js
export const SyncLane: Lane = /* */ 0b0000000000000000000000000000001;
```

From `SyncLane` down to `SelectiveHydrationLane`, the `priority` of the track is gradually reduced.

## Indicates the concept of "batch"

You can see that several variables occupy several tracks, such as:

```js
const InputDiscreteLanes: Lanes = /* */ 0b0000000000000000000000000011000;
export const DefaultLanes: Lanes = /* */ 0b0000000000000000000111000000000;
const TransitionLanes: Lanes = /* */ 0b0000000001111111110000000000000;
```

This is the concept of `batch`, called `lanes` (`lane` which is different from `priority`).

Among them, `InputDiscreteLanes` is the `priority` range that "user interaction" triggers the update will have.

`DefaultLanes` is the `priority` range of "trigger update after request data return".

`TransitionLanes` is the `priority` range owned by `Suspense`, `useTransition`, and `useDeferredValue`.

There is a detail in this, the lower the priority, the more bits occupied by `lanes`. For example, `InputDiscreteLanes` occupies 2 positions, and `TransitionLanes` occupies 9 positions.

The reason is: the lower the priority of the update, the easier it is to be interrupted, resulting in a backlog, so more bits are needed. On the contrary, the best synchronization update `SyncLane` does not require extra `lanes`.

## Facilitate priority related calculations

Since `lane` corresponds to binary bits, calculations related to `priority` are actually bit operations.

for example:

To calculate whether there is an intersection between the two `lane`s of `a` and `b`, you only need to determine whether the result of the bitwise AND of `a` and `b` is `0`:

```js
export function includesSomeLane(a: Lanes | Lane, b: Lanes | Lane) {
  return (a & b) !== NoLanes;
}
```

To calculate whether the `lanes` of `b` is a subset of `lanes` corresponding to `a`, it is only necessary to determine whether the result of the bitwise AND of `a` and `b` is `b`:

```js
export function isSubsetOfLanes(set: Lanes, subset: Lanes | Lane) {
  return (set & subset) === subset;
}
```

Combining the bits of two `lane` or `lanes` only needs to perform a bitwise OR operation:

```js
export function mergeLanes(a: Lanes | Lane, b: Lanes | Lane): Lanes {
  return a | b;
}
```

To remove `subset` corresponding to `lane` (or `lanes`) from `set` corresponding to `lanes`, you only need to perform bitwise negation on `lane` (or `lanes`) of `subset`, and the result is correct again. set` performs bitwise AND.

```js
export function removeLanes(set: Lanes, subset: Lanes | Lane): Lanes {
  return set & ~subset;
}
```

> More bitwise operations reference [MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators)

## Summarize

This is the priority model `lane` model of `React`.

So far, we have understood the `Fiber` architecture, the `priority` of `update`, the implementation of `Scheduler`, and the `lane` model. From the next section, we will explain the various applications of `Concurrent Mode` step by step.